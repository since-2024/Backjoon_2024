> 알고리즘을 해결해가며 느낀점 + 개인적인 생각

---
## Dynamic Programming

- 특정 범위까지의 값을 구하기 위해 '이전 범위의 값을 활용'하여 효율적으로 값을 얻는 기법
- 이전 범위의 값을 저장(Memorization)하여, 똑같은 문제가 발생했을 때 이를 참조하여 해결함.

~~점화식을 만들어서 적용한다는 느낌으로 접근해 볼 예정~~

### #1904

``` python
dp = [0]*(n+1)

dp[1] = 1
dp[2] = 2

for i in range(3, n+1):
    dp[i] = ...
```

<details>
<summary> ... </summary>

    첫 DP 문제.
    점화식을 만들어서 푼다는 것 까지는 이해했으나, 아직 문제 풀이에 있어서는 감을 잡지 못한 상태 ㅠ
</details>

### #10870

<details>
<summary> ... </summary>

    처음 풀어본 문제보다 난이도 -1 같은 느낌.
    n이 0 인 경우 따로 처리하는 것보다 깔끔하게 풀어볼 방법을 생각 해봐야겠다.
</details>

### #1463
    처음에는 입력받은 값에 집중해서 점화식을 어떻게 세우나만 고민하다가,
    생각하다보니 1부터도 시작할 수 있었던 것,,
<details>
<summary> ... </summary>

    처음 풀어본 문제보다 난이도 +5 같은 느낌.
    이게 DP 문제구나 싶었다.
    
    유사한 DP 문제가 나온다면 거뜬하게 풀 수 있을 것 같다만,
    문제를 DP로 풀어야 한다는 점을 떠올릴 수 있는 방법이 미숙한 것 같다.
</details>

### #2239
    2와 5를 가지고 7을 만들려면 2+5 와 5+2.
    어디서부터 오느냐의 차이일뿐, 결국은 같은 경우.
<details>
<summary> ... </summary>

    이전 문제보다 난이도 +2 같은 느낌.

    유사한 DP 문제라고 생각했고, dp[0] 까지 초기화 값을 잘 넣어줬으나 생각보다 잘 안풀렸다.
    값을 만드는 방법에 치중하다보니 '구성이 같으나 순서가 다른 경우'를 고려하기가 어려웠다.


    실버 문제와 골드 문제가 괜히 나눠진게 아니구나 싶은 느낌을 받았다.

~~근데 돈을 안내는 경우는 "아무 것도 안낸다."라는 조건이니까 1이 맞겠지?~~
</details>